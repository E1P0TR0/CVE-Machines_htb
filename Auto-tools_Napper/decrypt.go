package main

import (
        "crypto/aes"
        "crypto/cipher"
        "encoding/base64"
        "fmt"
        "log"
        "math/rand"
        "strconv"
)

func checkErr(err error){
        if err != nil {
                log.Fatal(err)
        }
}

func generateKey(seed int) []byte {
        rand.Seed(int64(seed))
        key := make([]byte, 16)
        for i := range key {
                key[i] = byte(1 + rand.Intn(254))
        }
        return key
}

func decryptCFB(iv, ciphertext, key []byte) ([]byte, error) {
        block, err := aes.NewCipher(key)
        if err != nil {
                return nil, err
        }

        stream := cipher.NewCFBDecrypter(block, iv)
        plaintext := make([]byte, len(ciphertext))
        stream.XORKeyStream(plaintext, ciphertext)

        return plaintext, nil
}

func main() {
        // curl -sk 'https://<user>:<pass>@127.0.0.1:9200/_search?pretty=true' (seed key & blob)
        
        seed, err := strconv.Atoi("82468876") // CHANGE THIS

        key := generateKey(seed)

        decodedBlob, err := base64.URLEncoding.DecodeString("1d6ckNSX87u5N43bAcRww1c91yUH704l_JV3yPHGLxxUDubm8QGm3DZ7WnViXYdaDEKk3eaQZUw=") // CHANGE THIS
        if err != nil {
                fmt.Println("Error decoding base64:", err)
                return
        }

        iv := decodedBlob[:aes.BlockSize]
        encryptedData := decodedBlob[aes.BlockSize:]

        decryptedData, err := decryptCFB(iv, encryptedData, key)
        if err != nil {
                fmt.Println("Error decrypting data:", err)
                return
        }

        fmt.Printf("Key: %x\n", key)
        fmt.Printf("IV: %x\n", iv)
        fmt.Printf("Encrypted Data: %x\n", encryptedData)
        fmt.Printf("Decrypted Data: %s\n", decryptedData)
}